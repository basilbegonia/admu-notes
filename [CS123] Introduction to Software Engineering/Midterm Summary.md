# Introduction to Software Engineering

## Software in General
* **Software**
  * Computer Programs and Associated Documentation
  * Software Products: Generic or Custom, both a Good and a Service
  * Can be created by: developing new programs, configuring generic systems, reusing existing software
  * Can be bought or built by companies depending on needs
  * **Software Activities**: Progressive or Anti-Regressive
  * **Software Engineering**: 
    * SE is a set of methods, standards and procedures applied to the definition, development and maintenance of computer software.
    * SE seeks to bring discipline and rigor to the building and maintenance of software systems.
    * We depend heavility on software, yet SD field lacks discipline: delayed projects, costs and schedules slip.
* **Software Nature**
  * Intangible Production (High Product Costs)
  * Construction is **Intellectual Value Intensive**
  * Non-Consumable (Short Life Time, max 5 years)
  * We sell information and intensive/complex solutions, **An Information Service**
  * Malleable (Difficult to monitor)
  * Dynamic/Adaptable Environment
* **Software Quality**
  * Delivered on time, within budget and functional
  * High quality and performance (Efficient)
  * Usable and Flexible (UX)
  * Understandable and Maintainable (Docs, Long Term)
  * Reliable (Dependable)
  * Portable (Adaptable)
* **Facts about Software**
  * Software costs increase as hardware costs decline (Software Crisis)
  * **Known Software Failures**: Ariane 5, Therac-25, Mars Climate Orbiter
  * Modern aspects are more systematic: methods, languages, processes
  * Ability to produce more complex in general has increased
  * Software Production = Development + Maintenance (>60% of all development costs)

## Software Development Life Cycle
* **Life Cycle Model**: Theoretical phases involved in building software
* **Life Cycle**: Actual steps performed
* **Classical Life Cycle Model**:
  * Definition/Analysis: Planning, Requirements, Design
  * Development: Coding, Testing
  * Maintenance: Bug fixes, Updates (Perfect/Adaptive), Change Requirements => Retire
* **Waterfall Life Cycle Model**: 
  * Requirements: Explore the concept, get client requirements
  * Analysis: "What is the product supposed to do?" (Specification Document, Project Management Plan)
  * Design: "How the product does it" (Architectural design)
  * Implementation: Coding, Integration, Testing
  * Maintenance: Corrective (Bugs), Perfective (Performance/Functionality), Adaptive (Environment)
  * Retirement
* **Relative Costs**: The earlier we detect and correct a fault, the less it costs us
  * Coding: 1/6
  * Analysis&Design: 1/3
  * Testing: 1/2
  * **Of Fixing**: 80% Design, 20% Logic/Syntax
* **Relative Errors**
  * Syntax: 1/6
  * Programming&Logic: 1/3
  * Design: 1/2

## Computation of Costs
* Requirements: 1
* Specification/Analysis: 2
* Planning: 3
* Design: 4
* Implementation: 10
* Integration: 30
* Maintenance: 200

## Maintenance
* **Classical Maintenance**: 
  * Develop-then-maintenance
  * Consequence: Development and Maintenance mostly depend on **when** they take place
* **Modern Maintenance**: 
  * "Process that occurs when a software artifact is modified because of a problem or because of a need for improvement or adaptation."
  * **Post-delivery Maintenance**: After delivery/installation
  * **(Modern) Maintenance**: Performed at any time
  * **Pros**: Software is constantly changing, good software is maintained for 10-20 years

## Testing and Documentation
* **Testing**
  * **Verification**: Done at the end of each phase
  * **Validation**: Done at the end of the project
  * Must be continual and carried by developers and QA
* **Documentation**
  * If key programmers leave before documenting, we cannot perform a phase, test or maintain a project without documentation
  * Must be performed in parallel with all other development/maintenance activities

# Team Management

# Software Project Management

# Software Life Cycle
